{"mappings":"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","sources":["node_modules/hyperapp/index.js","node_modules/hyperlit/index.js","node_modules/@mrbarrysoftware/hyperapp-router/node_modules/path-to-regexp/src/index.ts","node_modules/@mrbarrysoftware/hyperapp-router/src/withRouter/const.js","node_modules/@mrbarrysoftware/hyperapp-router/src/withRouter/lib/navigate.js","node_modules/@mrbarrysoftware/hyperapp-router/src/withRouter/subscriptions.js","node_modules/@mrbarrysoftware/hyperapp-router/src/withRouter/index.js","src/ui/components/component.ts","src/ui/components/pages/home.ts","src/ui/components/pages/xbull.ts","src/ui/components/pages/freighter.ts","src/ui/components/pages/albedo.ts","src/app.tsx"],"sourcesContent":["var SSR_NODE = 1\nvar TEXT_NODE = 3\nvar EMPTY_OBJ = {}\nvar EMPTY_ARR = []\nvar SVG_NS = \"http://www.w3.org/2000/svg\"\n\nvar id = (a) => a\nvar map = EMPTY_ARR.map\nvar isArray = Array.isArray\nvar enqueue =\n  typeof requestAnimationFrame !== \"undefined\"\n    ? requestAnimationFrame\n    : setTimeout\n\nvar createClass = (obj) => {\n  var out = \"\"\n\n  if (typeof obj === \"string\") return obj\n\n  if (isArray(obj)) {\n    for (var k = 0, tmp; k < obj.length; k++) {\n      if ((tmp = createClass(obj[k]))) {\n        out += (out && \" \") + tmp\n      }\n    }\n  } else {\n    for (var k in obj) {\n      if (obj[k]) out += (out && \" \") + k\n    }\n  }\n\n  return out\n}\n\nvar shouldRestart = (a, b) => {\n  for (var k in { ...a, ...b }) {\n    if (typeof (isArray(a[k]) ? a[k][0] : a[k]) === \"function\") {\n      b[k] = a[k]\n    } else if (a[k] !== b[k]) return true\n  }\n}\n\nvar patchSubs = (oldSubs, newSubs = EMPTY_ARR, dispatch) => {\n  for (\n    var subs = [], i = 0, oldSub, newSub;\n    i < oldSubs.length || i < newSubs.length;\n    i++\n  ) {\n    oldSub = oldSubs[i]\n    newSub = newSubs[i]\n\n    subs.push(\n      newSub && newSub !== true\n        ? !oldSub ||\n          newSub[0] !== oldSub[0] ||\n          shouldRestart(newSub[1], oldSub[1])\n          ? [\n              newSub[0],\n              newSub[1],\n              (oldSub && oldSub[2](), newSub[0](dispatch, newSub[1])),\n            ]\n          : oldSub\n        : oldSub && oldSub[2]()\n    )\n  }\n  return subs\n}\n\nvar getKey = (vdom) => (vdom == null ? vdom : vdom.key)\n\nvar patchProperty = (node, key, oldValue, newValue, listener, isSvg) => {\n  if (key === \"key\") {\n  } else if (key === \"style\") {\n    for (var k in { ...oldValue, ...newValue }) {\n      oldValue = newValue == null || newValue[k] == null ? \"\" : newValue[k]\n      if (k[0] === \"-\") {\n        node[key].setProperty(k, oldValue)\n      } else {\n        node[key][k] = oldValue\n      }\n    }\n  } else if (key[0] === \"o\" && key[1] === \"n\") {\n    if (\n      !((node.events || (node.events = {}))[(key = key.slice(2))] = newValue)\n    ) {\n      node.removeEventListener(key, listener)\n    } else if (!oldValue) {\n      node.addEventListener(key, listener)\n    }\n  } else if (!isSvg && key !== \"list\" && key !== \"form\" && key in node) {\n    node[key] = newValue == null ? \"\" : newValue\n  } else if (\n    newValue == null ||\n    newValue === false ||\n    (key === \"class\" && !(newValue = createClass(newValue)))\n  ) {\n    node.removeAttribute(key)\n  } else {\n    node.setAttribute(key, newValue)\n  }\n}\n\nvar createNode = (vdom, listener, isSvg) => {\n  var props = vdom.props\n  var node =\n    vdom.type === TEXT_NODE\n      ? document.createTextNode(vdom.tag)\n      : (isSvg = isSvg || vdom.tag === \"svg\")\n      ? document.createElementNS(SVG_NS, vdom.tag, props.is && props)\n      : document.createElement(vdom.tag, props.is && props)\n\n  for (var k in props) {\n    patchProperty(node, k, null, props[k], listener, isSvg)\n  }\n\n  for (var i = 0; i < vdom.children.length; i++) {\n    node.appendChild(\n      createNode(\n        (vdom.children[i] = maybeVNode(vdom.children[i])),\n        listener,\n        isSvg\n      )\n    )\n  }\n\n  return (vdom.node = node)\n}\n\nvar patch = (parent, node, oldVNode, newVNode, listener, isSvg) => {\n  if (oldVNode === newVNode) {\n  } else if (\n    oldVNode != null &&\n    oldVNode.type === TEXT_NODE &&\n    newVNode.type === TEXT_NODE\n  ) {\n    if (oldVNode.tag !== newVNode.tag) node.nodeValue = newVNode.tag\n  } else if (oldVNode == null || oldVNode.tag !== newVNode.tag) {\n    node = parent.insertBefore(\n      createNode((newVNode = maybeVNode(newVNode)), listener, isSvg),\n      node\n    )\n    if (oldVNode != null) {\n      parent.removeChild(oldVNode.node)\n    }\n  } else {\n    var tmpVKid\n    var oldVKid\n\n    var oldKey\n    var newKey\n\n    var oldProps = oldVNode.props\n    var newProps = newVNode.props\n\n    var oldVKids = oldVNode.children\n    var newVKids = newVNode.children\n\n    var oldHead = 0\n    var newHead = 0\n    var oldTail = oldVKids.length - 1\n    var newTail = newVKids.length - 1\n\n    isSvg = isSvg || newVNode.tag === \"svg\"\n\n    for (var i in { ...oldProps, ...newProps }) {\n      if (\n        (i === \"value\" || i === \"selected\" || i === \"checked\"\n          ? node[i]\n          : oldProps[i]) !== newProps[i]\n      ) {\n        patchProperty(node, i, oldProps[i], newProps[i], listener, isSvg)\n      }\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldHead])) == null ||\n        oldKey !== getKey(newVKids[newHead])\n      ) {\n        break\n      }\n\n      patch(\n        node,\n        oldVKids[oldHead].node,\n        oldVKids[oldHead],\n        (newVKids[newHead] = maybeVNode(\n          newVKids[newHead++],\n          oldVKids[oldHead++]\n        )),\n        listener,\n        isSvg\n      )\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldTail])) == null ||\n        oldKey !== getKey(newVKids[newTail])\n      ) {\n        break\n      }\n\n      patch(\n        node,\n        oldVKids[oldTail].node,\n        oldVKids[oldTail],\n        (newVKids[newTail] = maybeVNode(\n          newVKids[newTail--],\n          oldVKids[oldTail--]\n        )),\n        listener,\n        isSvg\n      )\n    }\n\n    if (oldHead > oldTail) {\n      while (newHead <= newTail) {\n        node.insertBefore(\n          createNode(\n            (newVKids[newHead] = maybeVNode(newVKids[newHead++])),\n            listener,\n            isSvg\n          ),\n          (oldVKid = oldVKids[oldHead]) && oldVKid.node\n        )\n      }\n    } else if (newHead > newTail) {\n      while (oldHead <= oldTail) {\n        node.removeChild(oldVKids[oldHead++].node)\n      }\n    } else {\n      for (var keyed = {}, newKeyed = {}, i = oldHead; i <= oldTail; i++) {\n        if ((oldKey = oldVKids[i].key) != null) {\n          keyed[oldKey] = oldVKids[i]\n        }\n      }\n\n      while (newHead <= newTail) {\n        oldKey = getKey((oldVKid = oldVKids[oldHead]))\n        newKey = getKey(\n          (newVKids[newHead] = maybeVNode(newVKids[newHead], oldVKid))\n        )\n\n        if (\n          newKeyed[oldKey] ||\n          (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))\n        ) {\n          if (oldKey == null) {\n            node.removeChild(oldVKid.node)\n          }\n          oldHead++\n          continue\n        }\n\n        if (newKey == null || oldVNode.type === SSR_NODE) {\n          if (oldKey == null) {\n            patch(\n              node,\n              oldVKid && oldVKid.node,\n              oldVKid,\n              newVKids[newHead],\n              listener,\n              isSvg\n            )\n            newHead++\n          }\n          oldHead++\n        } else {\n          if (oldKey === newKey) {\n            patch(\n              node,\n              oldVKid.node,\n              oldVKid,\n              newVKids[newHead],\n              listener,\n              isSvg\n            )\n            newKeyed[newKey] = true\n            oldHead++\n          } else {\n            if ((tmpVKid = keyed[newKey]) != null) {\n              patch(\n                node,\n                node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),\n                tmpVKid,\n                newVKids[newHead],\n                listener,\n                isSvg\n              )\n              newKeyed[newKey] = true\n            } else {\n              patch(\n                node,\n                oldVKid && oldVKid.node,\n                null,\n                newVKids[newHead],\n                listener,\n                isSvg\n              )\n            }\n          }\n          newHead++\n        }\n      }\n\n      while (oldHead <= oldTail) {\n        if (getKey((oldVKid = oldVKids[oldHead++])) == null) {\n          node.removeChild(oldVKid.node)\n        }\n      }\n\n      for (var i in keyed) {\n        if (newKeyed[i] == null) {\n          node.removeChild(keyed[i].node)\n        }\n      }\n    }\n  }\n\n  return (newVNode.node = node)\n}\n\nvar propsChanged = (a, b) => {\n  for (var k in a) if (a[k] !== b[k]) return true\n  for (var k in b) if (a[k] !== b[k]) return true\n}\n\nvar maybeVNode = (newVNode, oldVNode) =>\n  newVNode !== true && newVNode !== false && newVNode\n    ? typeof newVNode.tag === \"function\"\n      ? ((!oldVNode ||\n          oldVNode.memo == null ||\n          propsChanged(oldVNode.memo, newVNode.memo)) &&\n          ((oldVNode = newVNode.tag(newVNode.memo)).memo = newVNode.memo),\n        oldVNode)\n      : newVNode\n    : text(\"\")\n\nvar recycleNode = (node) =>\n  node.nodeType === TEXT_NODE\n    ? text(node.nodeValue, node)\n    : createVNode(\n        node.nodeName.toLowerCase(),\n        EMPTY_OBJ,\n        map.call(node.childNodes, recycleNode),\n        SSR_NODE,\n        node\n      )\n\nvar createVNode = (tag, props, children, type, node) => ({\n  tag,\n  props,\n  key: props.key,\n  children,\n  type,\n  node,\n})\n\nexport var memo = (tag, memo) => ({ tag, memo })\n\nexport var text = (value, node) =>\n  createVNode(value, EMPTY_OBJ, EMPTY_ARR, TEXT_NODE, node)\n\nexport var h = (tag, props, children = EMPTY_ARR) =>\n  createVNode(tag, props, isArray(children) ? children : [children])\n\nexport var app = ({\n  node,\n  view,\n  subscriptions,\n  dispatch = id,\n  init = EMPTY_OBJ,\n}) => {\n  var vdom = node && recycleNode(node)\n  var subs = []\n  var state\n  var busy\n\n  var update = (newState) => {\n    if (state !== newState) {\n      if ((state = newState) == null) dispatch = subscriptions = render = id\n      if (subscriptions) subs = patchSubs(subs, subscriptions(state), dispatch)\n      if (view && !busy) enqueue(render, (busy = true))\n    }\n  }\n\n  var render = () =>\n    (node = patch(\n      node.parentNode,\n      node,\n      vdom,\n      (vdom = view(state)),\n      listener,\n      (busy = false)\n    ))\n\n  var listener = function (event) {\n    dispatch(this.events[event.type], event)\n  }\n\n  return (\n    (dispatch = dispatch((action, props) =>\n      typeof action === \"function\"\n        ? dispatch(action(state, props))\n        : isArray(action)\n        ? typeof action[0] === \"function\"\n          ? dispatch(action[0], action[1])\n          : action\n              .slice(1)\n              .map(\n                (fx) => fx && fx !== true && fx[0](dispatch, fx[1]),\n                update(action[0])\n              )\n        : update(action)\n    ))(init),\n    dispatch\n  )\n}\n","import { h, text } from 'hyperapp'\n\nconst NEXT = 0\nconst TEXT = 1\nconst TAG = 2\nconst CLOSINGTAG = 3\nconst TAGNAME = 4\nconst PROPS = 5\nconst SELFCLOSING = 6\nconst PROPNAME = 7\nconst PROPVAL = 8\nconst PROPVALSTR = 9\n\nconst ws = (c) => c == ' ' || c == '\\t' || c == '\\n' || c == '\\r'\n\nconst parse = (strs, vals) => {\n    let tagname,\n        propname,\n        props,\n        parent,\n        list = [],\n        ch,\n        buffer = '',\n        mode = NEXT,\n        newline = true\n\n    const listpush = (x) => (x || x === 0)  && list.push(typeof x == 'string' ? text(x) : typeof x == 'number' ? text(''+x) : x)\n\n    const pushnode = (ch, children = ch.flat(2)) => {\n        listpush(tagname.call ? tagname(props, children) : h(tagname, props, children))\n        mode = NEXT\n    }\n\n    const gotText = (trim) => {\n        if (trim) buffer = buffer.trimEnd()\n        buffer && listpush(buffer)\n        newline = false\n        buffer = ''\n    }\n\n    const open = () => {\n        parent = [list, tagname, props, parent]\n        list = []\n        mode = NEXT\n    }\n\n    const gotTagName = (m = mode) => {\n        tagname = buffer\n        buffer = ''\n        props = {}\n        mode = m\n    }\n\n    const defaultProp = (m = mode) => {\n        props[buffer] = true\n        mode = m\n        buffer = ''\n    }\n\n    const gotProp = (v) => {\n        props[propname] = v\n        mode = PROPS\n        buffer = ''\n    }\n\n    const close = () => {\n        let children = list\n        ;[list, tagname, props, parent] = parent\n        pushnode(children)\n    }\n\n    for (let j = 0; j < strs.length; j++) {\n        for (let i = 0; i < strs[j].length; i++) {\n            ch = strs[j][i]\n            if (mode == NEXT) {\n                if (ch == '<') {\n                    mode = TAG\n                } else if (!ws(ch)) {\n                    mode = TEXT\n                    buffer = ch\n                } else if (ch =='\\n') {\n                    newline = true\n                } else if (!newline) {\n                    mode = TEXT\n                    buffer = ch\n                }\n            } else if (mode == TEXT) {\n                if (ch == '<') {\n                    mode = TAG\n                } else if (ch == '\\n') {\n                    gotText(false)\n                    newline = true\n                    mode = NEXT\n                } else {\n                    buffer += ch\n                }\n            } else if (mode == TAG) {\n                if (ch == '/') {\n                    mode = CLOSINGTAG\n                    gotText(true)\n                } else {\n                    mode = TAGNAME\n                    gotText(false)\n                    buffer = ch\n                }\n            } else if (mode == CLOSINGTAG) {\n                if (ch == '>') close()\n            } else if (mode == TAGNAME) {\n                if (ws(ch)) {\n                    gotTagName(PROPS)\n                } else if (ch == '/') {\n                    gotTagName(SELFCLOSING)\n                } else if (ch == '>') {\n                    gotTagName()\n                    open()\n                } else {\n                    buffer += ch\n                }\n            } else if (mode == SELFCLOSING) {\n                if (ch == '>') {\n                    pushnode([])\n                }\n            } else if (mode == PROPS) {\n                if (ch == '.') {\n                } else if (ch == '/') {\n                    mode = SELFCLOSING\n                } else if (ch == '>') {\n                    open()\n                } else if (!ws(ch)) {\n                    buffer = ch\n                    mode = PROPNAME\n                }\n            } else if (mode == PROPNAME) {\n                if (ch == '=') {\n                    propname = buffer\n                    mode = PROPVAL\n                } else if (ch == '>') {\n                    defaultProp()\n                    open()\n                } else if (ch == '/') {\n                    defaultProp(SELFCLOSING)\n                } else if (ws(ch)) {\n                    defaultProp(PROPS)\n                } else {\n                    buffer += ch\n                }\n            } else if (mode == PROPVAL) {\n                if (ch == '\"') {\n                    mode = PROPVALSTR\n                    buffer = ''\n                }\n            } else if (mode == PROPVALSTR) {\n                if (ch == '\"') {\n                    gotProp(buffer)\n                } else {\n                    buffer += ch\n                }\n            }\n        }\n        if (mode == TAG) {\n            tagname = vals[j]\n            props = {}\n            mode = PROPS\n        } else if (mode == TEXT) {\n            gotText(!vals[j])\n            listpush(vals[j])\n        } else if (mode == PROPS) {\n            props = { ...props, ...vals[j] }\n        } else if (mode == PROPVAL) {\n            gotProp(vals[j])\n        } else if (mode == PROPVALSTR) {\n            buffer += vals[j]\n        } else if (mode == NEXT && vals[j] != null) {\n            listpush(vals[j])\n        }\n    }\n    list = list.flat(2)\n    return list.length > 1 ? list : list[0]\n}\n\nexport default (strs, ...vals) => parse(strs, vals)\n","/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    // tslint:disable-next-line\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map(token => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function(pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\"\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map(path => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x\n  } = options;\n  const endsWith = `[${escapeString(options.endsWith || \"\")}]|$`;\n  const delimiter = `[${escapeString(options.delimiter || \"/#?\")}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiter}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWith})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n        : // tslint:disable-next-line\n          endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiter}(?=${endsWith}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiter}|${endsWith})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n","export const ROUTER_EVENT = 'hyperapp-router-navigate';\n","import * as constants from '../const';\n\nexport const navigate = (href, options = { type: 'push' }) => {\n  const event = new CustomEvent(constants.ROUTER_EVENT, {\n    detail: {\n      ...options,\n      href,\n    },\n  });\n\n  document.dispatchEvent(event);\n};\n\n","import * as constants from './const';\nimport { navigate } from './lib/navigate';\n\nconst makeFindRouteAndMatch = (routes) => (href) => {\n  let route;\n  for (route of routes) {\n    const match = route.match(href);\n    if (!match) continue;\n\n    return { route, match };\n  }\n\n  return null;\n};\n\nconst PushFX = (dispatch, props) => {\n  let currentRoute = {};\n\n  const findRouteAndMatch = makeFindRouteAndMatch(props.routes);\n\n  const setCurrentRoute = (route, match) => {\n    if (currentRoute.OnLeave) {\n      dispatch(currentRoute.OnLeave, currentRoute.params);\n    }\n\n    if (props.RouteAction) {\n      dispatch(props.RouteAction, {\n        params: match.params,\n        path: match.path,\n      });\n    }\n\n    currentRoute = {\n      ...route,\n      params: match.params,\n    };\n\n    if (currentRoute.OnEnter) {\n      dispatch(currentRoute.OnEnter, currentRoute.params);\n    }\n  };\n\n  const onPush = (route, match) => {\n    setCurrentRoute(route, match);\n    window.history.pushState({}, '', match.path);\n  };\n\n  const onReplace = (route, match) => {\n    setCurrentRoute(route, match);\n    window.history.replaceState({}, '', match.path);\n  };\n\n  const getNavigateMethod = (type) => {\n    switch (type) {\n    case 'replace':\n      return onReplace;\n\n    default:\n      return onPush;\n    }\n  }\n\n  const onNavigate = (event) => {\n    const method = getNavigateMethod(event.detail.type);\n    const result = findRouteAndMatch(event.detail.href);\n    return method(result.route, result.match);\n  };\n  document.addEventListener(constants.ROUTER_EVENT, onNavigate);\n\n  const onPop = (event) => {\n    const result = findRouteAndMatch(event.originalTarget.location.pathname);\n    return setCurrentRoute(result.route, result.match);\n  };\n  window.addEventListener('popstate', onPop);\n\n  const init = () => {\n    return onPop({ originalTarget: window });\n  };\n\n  setTimeout(init, 0);\n\n  return () => {\n    document.removeEventListener(constants.ROUTER_EVENT, onNavigate);\n    window.removeEventListener('popstate', onPop);\n  };\n};\nexport const Push = (props) => [PushFX, props];\n\nconst AnchorFX = (_dispatch, props) => {\n  const findRouteAndMatch = makeFindRouteAndMatch(props.routes);\n\n  const onClick = (event) => {\n    if (!event.target.matches('a')) return null;\n\n    const href = event.target.getAttribute('href');\n    if (!findRouteAndMatch(href)) return null;\n\n    event.preventDefault();\n    return navigate(href, { type: 'push' });\n  };\n  document.addEventListener('click', onClick);\n\n  return () => {\n    document.removeEventListener('click', onClick);\n  };\n};\nexport const Anchor = props => [AnchorFX, props];\n","import { match } from 'path-to-regexp';\n\nimport * as subscriptions from './subscriptions';\n\nconst ensureStartsWithSlash = part => (\n  `/${part.replace(/^\\/+/, '')}`\n);\n\nconst routesToArray = ({ routes: routesObject, baseUrl }) => Object.keys(routesObject)\n  .reduce((routes, initialPath) => {\n    const path = ensureStartsWithSlash([\n      baseUrl.replace(/.+(\\/$)/, ''),\n      initialPath.replace(/^\\/+/, ''),\n    ]\n      .map(ensureStartsWithSlash)\n      .join(''));\n\n    const route = {\n      ...routesObject[initialPath],\n      path,\n      match: match(path),\n    }\n\n    return [\n      ...routes,\n      route,\n    ];\n  }, []);\n\nexport default (app) => ({ router, ...rest }) => {\n  const originalSubscriptions = rest.subscriptions\n    ? rest.subscriptions\n    : () => [];\n\n  const routes = routesToArray({\n    baseUrl: '',\n    ...router,\n  });\n\n  return app({\n    ...rest,\n    subscriptions: (state) => [\n      ...originalSubscriptions(state),\n      subscriptions.Push({\n        routes,\n        RouteAction: router.RouteAction,\n      }),\n      !router.disableAnchorCapture && subscriptions.Anchor({\n        routes,\n      }),\n    ],\n  });\n};\n","import homePage from \"./pages/home\";\nimport xbullPage from \"./pages/xbull\";\nimport freighterPage from \"./pages/freighter\";\nimport albedoPage from \"./pages/albedo\";\n\nconst components = {\n  homePage,\n  xbullPage,\n  freighterPage,\n  albedoPage,\n};\n\nexport default components;\n","import html from \"hyperlit\";\n\nconst homePage = html`<div>\n  <ul>\n    <button><a href=\"/xbull\">Connect with xBull</a></button>\n    <button><a href=\"/albedo\">Connect with Albedo</a></button>\n    <button><a href=\"/freighter\">Connect with Freighter</a></button>\n  </ul>\n</div>`;\n\nexport default homePage;\n","import html from \"hyperlit\";\n\nconst xbullPage = html`<div>XBULL</div>`;\n\nexport default xbullPage;\n","import html from \"hyperlit\";\n\nconst freighterPage = html`<div>FREIGHTER</div>`;\n\nexport default freighterPage;\n","import html from \"hyperlit\";\n\nconst albedoPage = html`<div>ALBEDOS</div>`;\n\nexport default albedoPage;\n","import { app } from \"hyperapp\";\nimport html from \"hyperlit\";\nimport withRouter from \"@mrbarrysoftware/hyperapp-router\";\nimport IState from \"./ui/state/state\";\nimport components from \"./ui/components/component\";\n\nconst baseState: IState = {\n  viewFn: () => html`<div></div>`,\n};\n\nwithRouter(app)({\n  router: {\n    disableAnchorCapture: true,\n    routes: {\n      \"/\": {\n        OnEnter: (state: IState) => ({\n          ...state,\n          viewFn: () => {\n            return components.homePage;\n          },\n        }),\n      },\n      \"/xbull\": {\n        OnEnter: (state: IState) => ({\n          ...state,\n          viewFn: () => {\n            return components.xbullPage;\n          },\n        }),\n      },\n      \"/albedo\": {\n        OnEnter: (state: IState) => ({\n          ...state,\n          viewFn: () => {\n            return components.albedoPage;\n          },\n        }),\n      },\n      \"/freighter\": {\n        OnEnter: (state: IState) => ({\n          ...state,\n          viewFn: () => {\n            return components.freighterPage;\n          },\n        }),\n      },\n    },\n  },\n\n  init: baseState,\n  view: (state: IState) => state.viewFn(),\n\n  node: document.getElementById(\"app\"),\n});\n\n//comment to be able to make a new PR\n"],"names":["$079b1ffbc7d5b2a4$var$EMPTY_OBJ","$079b1ffbc7d5b2a4$var$EMPTY_ARR","$079b1ffbc7d5b2a4$var$id","a","$079b1ffbc7d5b2a4$var$map","map","$079b1ffbc7d5b2a4$var$isArray","Array","isArray","$079b1ffbc7d5b2a4$var$enqueue","requestAnimationFrame","setTimeout","$079b1ffbc7d5b2a4$var$createClass","obj","out","tmp","k","length","$079b1ffbc7d5b2a4$var$shouldRestart","b","$079b1ffbc7d5b2a4$var$getKey","vdom","key","$079b1ffbc7d5b2a4$var$patchProperty","node","oldValue","newValue","listener","isSvg","setProperty","events","slice","addEventListener","removeEventListener","removeAttribute","setAttribute","$079b1ffbc7d5b2a4$var$createNode","props","type","document","createTextNode","tag","createElementNS","is","createElement","i","children","appendChild","$079b1ffbc7d5b2a4$var$maybeVNode","$079b1ffbc7d5b2a4$var$patch","parent","oldVNode","newVNode","nodeValue","insertBefore","removeChild","tmpVKid","oldVKid","oldKey","newKey","oldProps","newProps","oldVKids","newVKids","oldHead","newHead","oldTail","newTail","keyed","newKeyed","memo","$079b1ffbc7d5b2a4$var$propsChanged","$079b1ffbc7d5b2a4$export$6f093cfa640b7166","$079b1ffbc7d5b2a4$var$recycleNode","nodeType","$079b1ffbc7d5b2a4$var$createVNode","nodeName","toLowerCase","call","childNodes","value","$addda2bc36e1a3a4$var$ws","c","$addda2bc36e1a3a4$var$parse","strs","vals","tagname","propname","ch1","list","buffer","mode","newline","listpush","x","push","pushnode","ch","flat","$079b1ffbc7d5b2a4$export$dda1d9f60106f0e9","gotText","trim","trimEnd","open","gotTagName","m","defaultProp","gotProp","v","close","j","$addda2bc36e1a3a4$export$2e2bcd8739ae039","$c093eac03829cd96$export$98e6a39c04603d36","str","options","tokens","char","index","count","pattern","TypeError","name","code","charCodeAt","$c093eac03829cd96$var$lexer","_a1","prefixes","defaultPattern","$c093eac03829cd96$var$escapeString","delimiter","result1","path","tryConsume","mustConsume","undefined","_a","nextType","consumeText","result","prefix","indexOf","suffix","modifier","value1","name_1","pattern_1","$c093eac03829cd96$export$4659b591c19bdf3d","keys","re","decode","pathname","exec","params","Object","create","_loop_1","split","$c093eac03829cd96$export$968e97c88708237a","$c093eac03829cd96$export$71304158c7e35877","replace","$c093eac03829cd96$var$flags","sensitive","$c093eac03829cd96$var$stringToRegexp","strict","_b","start","_c","end","_d","encode","endsWith","route","_i","tokens_1","token","mod","endToken","isEndDelimited","RegExp","$c093eac03829cd96$export$9a9303716def6456","groupsRegex","execResult","source","$c093eac03829cd96$var$regexpToRegexp","paths","parts","join","$c093eac03829cd96$var$arrayToRegexp","$c100ab8e99e21126$export$ff7962acd6052c28","href","event","CustomEvent","detail","dispatchEvent","$3609dcf7500aed9a$var$makeFindRouteAndMatch","routes","match","$3609dcf7500aed9a$var$PushFX","dispatch","currentRoute","findRouteAndMatch","setCurrentRoute","OnLeave","RouteAction","OnEnter","onPush","window","history","pushState","onReplace","replaceState","onNavigate","method","onPop","originalTarget","location","$3609dcf7500aed9a$var$AnchorFX","_dispatch","onClick","target","matches","getAttribute","preventDefault","$3609dcf7500aed9a$export$b688253958b8dfe7","$654f255ec80fa9b2$var$ensureStartsWithSlash","part","$cd791a2424d2fa60$export$2e2bcd8739ae039","$e285f3d14bf0984c$var$baseState","viewFn","app","router","rest","originalSubscriptions","subscriptions","routesObject","baseUrl","reduce","initialPath","$654f255ec80fa9b2$var$routesToArray","state","disableAnchorCapture","$67d26835d712d95a$export$2e2bcd8739ae039","view","init","busy","subs","update","newState","render","oldSubs","newSubs","oldSub","newSub","$079b1ffbc7d5b2a4$var$patchSubs","parentNode","this","action","fx","homePage","xbullPage","albedoPage","freighterPage","getElementById"],"version":3,"file":"index.74106f44.js.map"}